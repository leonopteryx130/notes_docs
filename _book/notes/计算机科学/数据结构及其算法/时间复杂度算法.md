# 时间复杂度算法

先看一段伪代码：
```
输入 n             // 接收 n 的值
p <- 1             // p 的初值置为 1
for i<-1 to n：    // i 的值从 1 到 n，每次将 p*i 的值赋值给 p
    p <- p * i     
Print p            // 输出 p 的值
```

这段代码用于求n的阶乘，如果要计算这段代码的时间复杂度，可以先统计各个步骤的执行次数，如下：

```
输入 n                 //执行 1 次
p <- 1                 //执行 1 次
for i<-1 to n：        //i 的值从 1 遍历到 n，当 i 的值为 n+1 的时候退出循环，总共执行 n+1 次
    p <- p * i         //i 从 1 到 n 的过程，共执行 n 次
Print p                //执行 1 次
```
累计得到总执行次数为2n+4次，这个表达式可以作为算法执行时间的估值，时间估值长短与n的大小有关。

每一种算法的运行时间都可以用类似2n+4，3n^2+4n+5这类表达式表示，但是这类表达式不够简洁，相互之间不容易比较，因此以3n^2+4n+5为例对表达式进行简化：
1. 当 n 无限大时，3n^2+4n 与 3n^2+4n+5 的值非常接近，是否加 5 对表达式的值影响不大，因此表达式可以简化为 3n^2+4n；
2. 当 n 无限大时，3n^2 的值要远远大于 4n 的值，它们之间类似于 10000 和 1 之间的关系，因此是否加 4n 对表达式最终的值影响不大，整个表达式可以简化为 3n^2；
3. 当 n 无限大时，n^2 的值已经超级大，是否乘 3 对最终结果影响不大，整个表达式可以简化为  n^2。

基于“n 值无限大”的思想，3n^2+4n+5 最终就简化成了 n^2。同样的道理，2n+4 可以简化为 n。无论多么复杂的表达式，都可以采用这种方式进行简化。采用大O记法表示算法执行时间，例：O(频度)
采用大 O 记法，2n+4 可以用O(n)表示，3n^2+4n+5 可以用O(n^2)表示。如果一个算法对应的表达式中没有变量（比如 10，100 等），则用O(1)表示算法的执行时间。

如果一个算法的执行时间最终估算为 O(n)，那么该算法的时间复杂度就是 O(n)。如下列举了常用的几种时间复杂度以及它们之间的大小关系：
O(1)< O(logn) < O(n) < O(n^2) < O(n^3) < O(2n)
O(1)是最小的，对应的算法的执行时间最短，执行效率最高。